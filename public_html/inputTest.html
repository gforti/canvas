<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>TODO supply a title</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <style>
            #game {                   
                border: 1px solid black;
            }
        </style>
    </head>
    <body>
        <canvas id="game" width="256" height="256"></canvas>
        
        <script type="text/javascript" src="js/data.js"></script>
        <script type="text/javascript" src="js/tile.js"></script>
        <script type="text/javascript" src="js/input.js"></script>
        <script type="text/javascript" src="js/entity.js"></script>
        
        <script type="text/javascript">
            
            

            window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                                  window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

            window.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;



             var myReq;
             
             var mapchangeData = {
                "dir": 'bottom',
                "map": [],
                "viewport": 0
                
            };
            
            
            
            var game = {};

            game.canvas = document.getElementById('game');
            game.canvasCTX = game.canvas.getContext('2d');
            
            game.canvasTileRows = Math.floor(game.canvas.height/data.tile.size);
            game.canvasTileCols = Math.floor(game.canvas.width/data.tile.size);
            
           
                       
            game.draw = function() {
                game.canvasCTX.clearRect(0,0,game.canvas.width+1, game.canvas.height+1);
                
                game.hero.move(game.input);
                
                
                if ( game.hero.collisionCanvasRight(game.canvas) && data.game.world[data.game.map].exits.right.length ) {
                    data.game.map = data.game.world[data.game.map].exits.right;
                    game.hero.col = 0;
                   
                }
                
                if ( game.hero.collisionCanvasLeft(game.canvas) && data.game.world[data.game.map].exits.left.length ) {
                    data.game.map = data.game.world[data.game.map].exits.left;
                    game.hero.col = (game.canvasTileCols-1)*data.tile.size;
                    //console.log(game.canvasTileCols);
                }
                
                
                 if ( game.hero.collisionCanvasTop(game.canvas) && data.game.world[data.game.map].exits.top.length ) {
                    //data.game.map = data.game.world[data.game.map].exits.top;
                    //game.hero.row = (game.canvasTileRows-1)*data.tile.size;
                   
                   mapchangeData.map = data.game.world[data.game.world[data.game.map].exits.top].map.concat(data.game.world[data.game.map].map);
                    
                    
                   mapchangeData.viewport = game.canvasTileRows;
                    myReq = requestAnimationFrame(changeMapTop);
                   
                }
                
                 if ( game.hero.collisionCanvasBottom(game.canvas) && data.game.world[data.game.map].exits.bottom.length ) {
                    //data.game.map = data.game.world[data.game.map].exits.bottom;
                    //game.hero.row = 0;
                    
                    mapchangeData.map = data.game.world[data.game.map].map.concat(data.game.world[data.game.world[data.game.map].exits.bottom].map);
                    
                    myReq = requestAnimationFrame(changeMapBottom);
                                        
                    
                    //console.log(game.canvasTileCols);
                }
                
                if ( game.hero.collisionCanvas(game.canvas) ) {
                    game.hero.collisionEntityFix(game.input);
                }
                
                game.drawTileSet();
                game.hero.draw(game.canvasCTX);
                return this;
            };
            
            game.hero = new Entity(data.hero);
            game.input = new Input(game.draw);
                       
            game.tileSheet = new Tile(data.tile,game.draw);
             
             // todo: remove reference to data
            game.drawTileSet = function() {
                var undfind;
                
                for (var r = 0; r < game.canvasTileRows; r++) {
                   for (var c = 0; c < game.canvasTileCols; c++) {
                      var tile = data.game.world[data.game.map].map[ r ][ c ];
                      if ( null === tile || undfind === tile ) continue;
                      var tileRow = (tile / game.tileSheet.rows) | 0; // Bitwise OR operation
                      var tileCol = (tile % game.tileSheet.cols) | 0;
                      game.canvasCTX.drawImage(game.tileSheet.img, (tileCol * data.tile.size), (tileRow * data.tile.size), data.tile.size, data.tile.size, (c * data.tile.size), (r * data.tile.size), data.tile.size, data.tile.size);
                   }
                } 
                return this;
            };
            
            
            
            
            function changeMapBottom(){
                            
                var undfind;
                                
                
                game.canvasCTX.clearRect(0,0,game.canvas.width+1, game.canvas.height+1);
                
                for (var r = mapchangeData.viewport, rend = r+game.canvasTileRows; r < rend; r++) {
                    for (var c = 0; c < game.canvasTileCols; c++) {
                      var tile = mapchangeData.map[ r ][ c ];                      
                      if ( null === tile || undfind === tile ) continue;
                      var tileRow = (tile / game.tileSheet.rows) | 0; // Bitwise OR operation
                      var tileCol = (tile % game.tileSheet.cols) | 0;
                      game.canvasCTX.drawImage(game.tileSheet.img, (tileCol * data.tile.size), (tileRow * data.tile.size), data.tile.size, data.tile.size, (c * data.tile.size), ((r-mapchangeData.viewport) * data.tile.size), data.tile.size, data.tile.size);
                   }
                } 
            
                game.hero.row -= data.tile.size;
                game.hero.draw(game.canvasCTX);
                mapchangeData.viewport++;
                
                if ( mapchangeData.viewport === game.canvasTileRows) {
                    mapchangeData.viewport = 0;
                     mapchangeData.map = [];
                    data.game.map = data.game.world[data.game.map].exits.bottom;
                    game.hero.row = 0;
                    game.draw();
                    window.cancelAnimationFrame(myReq);
                } else {
                    requestAnimationFrame(changeMapBottom);
                }
                    
                
                
            }
            
            
            
            
            function changeMapTop(){
                            
                var undfind;
                                
                
                game.canvasCTX.clearRect(0,0,game.canvas.width+1, game.canvas.height+1);
                
                for (var r = mapchangeData.viewport, rend = r+game.canvasTileRows; r < rend; r++) {
                    for (var c = 0; c < game.canvasTileCols; c++) {
                      var tile = mapchangeData.map[ r ][ c ];                      
                      if ( null === tile || undfind === tile ) continue;
                      var tileRow = (tile / game.tileSheet.rows) | 0; // Bitwise OR operation
                      var tileCol = (tile % game.tileSheet.cols) | 0;
                      game.canvasCTX.drawImage(game.tileSheet.img, (tileCol * data.tile.size), (tileRow * data.tile.size), data.tile.size, data.tile.size, (c * data.tile.size), ((r-mapchangeData.viewport) * data.tile.size), data.tile.size, data.tile.size);
                   }
                } 
            
                game.hero.row += data.tile.size;
                game.hero.draw(game.canvasCTX);
                mapchangeData.viewport--;
                
                if ( mapchangeData.viewport === 0) {
                    mapchangeData.viewport = 0;
                    mapchangeData.map = [];
                    data.game.map = data.game.world[data.game.map].exits.top;
                    game.hero.row = (game.canvasTileRows-1)*data.tile.size;
                    game.draw();
                    window.cancelAnimationFrame(myReq);
                } else {
                    requestAnimationFrame(changeMapTop);
                }
                    
                
                
            }
            
            
              
            
            
            
        </script>
    
    </body>
</html>
